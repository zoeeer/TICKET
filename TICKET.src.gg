#--------------------------------------------------------------------------
# SPA Name:		Ticket
# Description:		A Simplified Railway Ticket System
#
#--------------------------------------------------------------------------
# Client FSM(s):
#			REGISTER
#			LOGIN
#			LOGOUT
#			RECHARGE
#--------------------------------------------------------------------------
# History:
#			2015-03-18  rangt	Created
#--------------------------------------------------------------------------

version "TICKET15F"

# Distributed and performance test enhancement
options (distributed,dg_cache=false,spa_timer_limit=200000,keep_on_lead=true)

########################################################################
########		   Common Definition			########
########################################################################
type
	Result_Code				enum {
		SUCCESS,
		FAIL,
		PENDING,
	}

	Order_State_enum enum{
		OS_UNPAIED = 0,	
		OS_PAIED = 1,
		OS_EXPAIRED = 2,
	}

	Parse_Result_rec			record {
		head			string,
		tail			string,
	}

	# Train info
	Train_Info_rec				record {
		Train_Number		string(4),
		Start_Station		string(30),
		Destination		string(30),
		Departure_Time		time,	# hhmm
		Arrival_Time		time,	# hhmm
		Duration		string(5),	# hhhmm
		Price			counter,
		Total			counter,
	}

	Ticket_Status_enum enum{
		TS_AVILABLE = 0,
		TS_RESERVED = 1,
		TS_PAYED = 2,
		TS_EXPAIRED = 3,
	}
	Session_Status_enum enum{
		SS_VALID,
		SS_EXPAIRED,
	}

	Audit_Tpye_enum enum{
		AT_NONE = 0,
		AT_SESSION = 1,
		AT_ORDER = 2,
		AT_TICKET = 3
	}
	Reserve_Failure_Code enum {
		RFC_INVALIED_ACTION = 0,
		RFC_NO_TICKET = 1,
		RFC_SYSTEM_BUSY = 2,
		RFC_SESSION_TIME_OUT = 3,
		RFC_TRAIN_TIME_PASSED = 4,
		RFC_ORDER_LIMIT	= 5,
		RFC_UNPAIED_ORDER = 6,
	}

end type

# Global rc
rc
	Train_Info		table	Train_Info_rec
	max_login		counter
	presale_day		counter
	#session expire check (s)
	session_expire_interval	counter
	session_audit_interval	counter
	#order expire check (s)
	order_audit_interval	counter
	order_expire_interval	counter
	#add new tickets
	tickets_expire_interval	counter
	tickets_audit_interval	counter
	#max tickets that in one order
	max_tickets_of_order	counter
	transaction_limits		counter
	user_lock_limits		counter
end rc

rtdb

	Ticket_Info_RTDB table record
	{
		Ticket_Id	string(16)	{key, name="TICKET_ID"},
		Train_Id	string(16)	{name="TRAIN_ID"},
		Start_Station	string(32)	{name="START_STATION"},
		End_Station	string(32)	{name="END_STATION"},
		Start_Time_ST	counter		{name="START_TIME_ST"},
		End_Time_ST	counter		{name="END_TIME_ST"},
		Price		counter,
		Total_Seats	counter,
		Available_Seats	counter,
	}

	User_Client_Map_RTDB table record
	{
		User_ID	string(32)	{key,name="USER_NAME"},
		Client_ID	string(32)	{name="CLIENT_ID"},
	}

	User_Account_RTDB		table	record {
		User_ID			string(32)	{key},
		Passwd			string(32),
		Name			string(32),
		Phone			string(16),
		Balance			counter,
		Registration_TS		counter,
	#	Last_Login_TS		counter,
		Latest_Index		counter,
		Order_ID_0		long_counter,
		Order_ID_1		long_counter,
		Order_ID_2		long_counter,
		Order_ID_3		long_counter,
		Order_ID_4		long_counter,
		Order_ID_5		long_counter,
		Order_ID_6		long_counter,
		Order_ID_7		long_counter,
		Order_ID_8		long_counter,
		Order_ID_9		long_counter,
	}

	Order_RTDB			table	record {
		Order_ID		long_counter	{key},
		Creation_TS		counter,
		Payment_TS		counter,
		User_ID			string(32),
		Ticket_ID		string(16),
		Train_Number		string(16),
		Train_Date		string(8),
		State			Order_State_enum,
	}

	Session_RTDB			table	record {
		Session_ID		string(20)	{key},
		User_ID			string(32),
		Client_ID		counter,
		Start_TS		counter,
		Last_Active_TS		counter,
	}
	
end rtdb

dataview

	register		table	{owner}	record {
		text			string(32)	{key},
		result_code		Result_Code,
		message			string(30),
	}

	login			table	{owner}	record {
		text			string(32)	{key},
		result_code		Result_Code,
		message			string(30),
	}

end dataview

########################################################################
########		   Server Definition			########
########################################################################
server
type
	Trans_Type enum {
		TT_NONE = 0,
		TT_CONTINUE = 1,
		TT_ROLL_BACK = 2,
	}
	Trans_Fail_Type enum {
		TST_TICKET_RTDB_FAIL = 0,
		TST_ORDER_RTDB_FAIL = 1,
		TST_USER_RTDB_FAIL =2,
		TST_ROLLBACK_ORDER_FAIL = 3,
		TST_ROOLLBACK_TICKET_FAIL = 4,
	}
	Reserve_Request  record {
		session_id		counter,	
		user_id		string,
		ticket_id		string,
		ticket_num	counter,
		call_id		 xp_dest,
		train_id		string,
		train_date		date,
		order_id			long_counter,
		fail_type		Trans_Fail_Type,
		Trans_Type	Trans_Type,
	}

	Per_User_Lock record {
		user_lock		flag,
	}
	

end type
dynamic
	Glb_Audit_FSM_Hdl			counter
	Glb_Ticketing_FSM_Hdl			counter
	Glb_Server_Current_Clock		counter
	
	Glb_Return_Val				reason_enum
	Glb_User_Account_RTDB			counter
	Glb_Session_RTDB			counter
	Glb_Ticket_Info_RTDB			counter
	Glb_Order_RTDB				counter
	Glb_User_Client_Map_RTDB		counter
	Glb_User_Order_RTDB			counter
	Glb_Ticket_Info_RTDB_Lock		flag
	#for order id generate
	Glb_Current_Order_Id			long_counter
	#for transaction management
	Glb_Trans_Continue_tbl 		table Reserve_Request
	Glb_Trans_Rollback_tbl 		table Reserve_Request
	Glb_Trans_Tbl_Limits		counter
	#for concurrency of sessions of the same user
	Glb_User_Lock_tbl			hash table(string) Per_User_Lock
	Glb_User_Lock_Tbl_Limits	counter
	
	a_z					string(26)
	A_Z					string(26)
	
	MAX_Balance				counter

	Glb_SPA_NAME				string
	Glb_Client_ID				counter

	# send om parameters
	GSL_Assert_Message_Class		message_class
	GSL_Assert_Priority			priority_of_action

	Glb_RTDB_Data_Assert_Title		string
	Glb_EPAY_RC_Assert_Title		string
	Glb_Dynamic_Data_Assert_Title		string
	Glb_Overflow_Assert_Title		string
	Glb_Internal_Operation_Assert_Title	string
	Glb_RTDB_Operation_Assert_Title		string
	# end semd om parameters

	Adjust_Server_Systime def_event{
	}
	RTDB_Init def_event {
	}
	Get_FSM_Handle def_event {
	}
	Init_Server_Audit def_event {
	}
	Transanction_Manage def_event {
	}
	Reserve_Continue def_event {
		request_info Reserve_Request
	}
	Deal_Next_Transaction def_event {
	}
	Deal_Next_Rollback def_event {
	}
	Check_Ticket_Info def_event {
	}
	Update_User_Info def_event {
	}
	Add_New_Order def_event {
	}
	Reserve_Ticket_failed def_event {
		fail_reason	Reserve_Failure_Code,
	}	
	Reserve_Ticket_success def_event {
		order_id long_counter,
	}
	
end dynamic

########## functions for server ###########
def_function Add_Continue_Transaction(
		request_info 	Reserve_Request
	) flag
	if table_length(Glb_Trans_Continue_tbl) >= Glb_Trans_Tbl_Limits
	then
		return(false)
	end if
	insert request_info into Glb_Trans_Continue_tbl
	return (true)
end def_function Add_Continue_Transaction

def_function Del_Continue_Transaction(
		request_info 	Reserve_Request
	) flag
	delete from Glb_Trans_Continue_tbl where Glb_Trans_Continue_tbl.session_id == request_info.session_id
	return (true)
end def_function Del_Continue_Transaction

def_function Add_Rollback_Transaction(
		request_info 	Reserve_Request
	) flag
	if table_length(Glb_Trans_Rollback_tbl) >= Glb_Trans_Tbl_Limits
	then
		return(false)
	end if
	insert request_info into Glb_Trans_Rollback_tbl
	return (true)
end def_function Add_Rollback_Transaction

def_function Del_Rollback_Transaction(
		request_info 	Reserve_Request
	) flag
	delete from Glb_Trans_Rollback_tbl where Glb_Trans_Rollback_tbl.session_id == request_info.session_id
	return(true)
end def_function Del_Rollback_Transaction

def_function Try_Lock_User(
	user_id	string) flag
dynamic
	Local_User_Lock	Per_User_Lock
end dynamic
	if  table_length(Glb_User_Lock_tbl) >= Glb_User_Lock_Tbl_Limits
	then 
		return(false)
	end if
	if element_exists(Glb_User_Lock_tbl, user_id) == true
	then
		if Glb_User_Lock_tbl[user_id].user_lock == true
		then
			return (false)
		else
			set Glb_User_Lock_tbl[user_id].user_lock = true
			return (true)
		end if
	else
		set Local_User_Lock.user_lock = true
		insert Local_User_Lock into Glb_User_Lock_tbl at user_id
		return (true)
	end if
end def_function Try_Lock_User

def_function UnLock_User(
	user_id	string) flag
	if element_exists(Glb_User_Lock_tbl, user_id) == true
	then
		set Glb_User_Lock_tbl[user_id].user_lock = false
	end if
	return (true)
end def_function UnLock_User

initialize
	set a_z = "abcdefghijklmnopqrstuvwxyz"
	set A_Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

	set Glb_SPA_NAME = "TICKET"
        set Glb_RTDB_Data_Assert_Title =
                        "REPT MANUAL ASSERT=103, SPA=" : Glb_SPA_NAME
	set Glb_EPAY_RC_Assert_Title =
                        "REPT MANUAL ASSERT=104, SPA=" : Glb_SPA_NAME

        set Glb_Dynamic_Data_Assert_Title =
                        "REPT INTERNAL ASSERT=302, SPA=" : Glb_SPA_NAME
        set Glb_Overflow_Assert_Title =
                        "REPT INTERNAL ASSERT=303, SPA=" : Glb_SPA_NAME
        set Glb_Internal_Operation_Assert_Title =
                        "REPT INTERNAL ASSERT=304, SPA=" : Glb_SPA_NAME
        set Glb_RTDB_Operation_Assert_Title =
                        "REPT INTERNAL ASSERT=305, SPA=" : Glb_SPA_NAME
         #set transaction limit
	set  Glb_Trans_Tbl_Limits = transaction_limits
	 #set user lock limits
	 set Glb_User_Lock_Tbl_Limits = user_lock_limits
         #set order id base value
         set Glb_Current_Order_Id =clock() * (hex_to_counter(hex_value("0x10000000")))*2
	set Glb_Server_Current_Clock = clock()	
	schedule(clock = Glb_Server_Current_Clock + 2, event = Adjust_Server_Systime, to=0)
	schedule(clock = Glb_Server_Current_Clock + 2, event = RTDB_Init, to=0)
	schedule(clock = clock() + 3, event = Get_FSM_Handle, to = 0)
	schedule(clock = clock() + 3, event = Init_Server_Audit, to = 0)
	schedule(clock = clock() + 3, event = Transanction_Manage, to = 0)

end initialize

fsm Srv_System_Clock
event Adjust_Server_Systime
	set Glb_Server_Current_Clock = clock()
	schedule(clock = Glb_Server_Current_Clock + 1, event = Adjust_Server_Systime, to=0)
end event

end fsm

fsm Srv_Audit_FSM
type

end type

call_dynamic
	Local_Retry_times			counter
	Init_Server_Audit_type def_event
	{
		Audit_Tpye 	Audit_Tpye_enum
	}
	Do_Server_Audit_type	def_event {
		Audit_Tpye 	Audit_Tpye_enum
	}
	Do_Server_Audit				Do_Server_Audit_type
	Local_Next_Session_Audit_Timing		counter
	Local_Next_Session_Audit_Flag		flag	
	Local_Session_Audit_Next		counter
	Do_Server_Session_Audit def_event {
	}
	Audit_Check_Session def_event {
		session_fields		Session_RTDB_fields
	}
	Audit_Delete_Session def_event {
		session_id		string
	}
	
	Local_Next_Order_Audit_Timing		counter
	Local_Next_Order_Audit_Flag		flag 	
	Local_Order_Audit_Next			counter
	Local_Order_Audit_Ticket_ID		string
	Do_Server_Order_Audit def_event {
	}
	Audit_Check_Order def_event {
		order_fields		Order_RTDB_fields
	}
	Audit_Delete_Order def_event {
		order_id		long_counter
	}
	Order_Audit_Read_Tickets def_event {
		ticket_id		string
	}
	Order_Audit_Update_Tickets def_event {
		ticket_info	Ticket_Info_RTDB_fields
	}
	Local_Next_Ticketing_Audit_Timing		counter
	Local_Next_Ticketing_Audit_Flag			flag 
	Local_Next_Ticketing_Audit_Day			date
	Local_Ticketing_Audit_Next			counter
	Local_Ticketing_Audit_Total			counter
	Do_Server_Ticketing_Audit def_event {
	}
	Action_Result				def_event {
		result			Result_Code,
		message			string
	}
	End_Call				def_event {}
	
end call_dynamic

access
	Srv_Audit_FSM_Routing_Key		routing_string
end access

### event defination
event RTDB_Init
	set Glb_Return_Val = User_Account_RTDB!attach ( "User_Account_RTDB" )
	if Glb_Return_Val == e_out_of_memory
	then
		set Glb_Return_Val = User_Account_RTDB!attach_no_cache("User_Account_RTDB" )
		if Glb_Return_Val != e_a_okay
		then
			#handle attach_no_cache error and
			print ("User_Account_RTDB attach_no_cache failure")
		end if
	elif Glb_Return_Val != e_a_okay
	then
		#handle non memory error and
		print ("User_Account_RTDB attach non memory error")
	end if
	set Glb_User_Account_RTDB = User_Account_RTDB!get_instance( "User_Account_RTDB" )

	set Glb_Return_Val = Session_RTDB!attach ( "Session_RTDB" )
	if Glb_Return_Val == e_out_of_memory
	then
		set Glb_Return_Val = Session_RTDB!attach_no_cache("Session_RTDB" )
		if Glb_Return_Val != e_a_okay
		then
			#handle attach_no_cache error and
			print ("Session_RTDB attach_no_cache failure")
		end if
	elif Glb_Return_Val != e_a_okay
	then
		#handle non memory error and
		print ("Session_RTDB attach non memory error")
	end if
	set Glb_Session_RTDB = Session_RTDB!get_instance( "Session_RTDB" )

#	next event End_Call
end event RTDB_Init

#---------------------------------------------------------------------------------
# Event:	Get_FSM_Handle
#
# Description: get FSM's Handle, which can be used to transfer the call instances
#							between FSMs.
#
#---------------------------------------------------------------------------------
event Get_FSM_Handle
	if Glb_Audit_FSM_Hdl == 0
	then
		set Glb_Audit_FSM_Hdl = routing_string!lookup(Srv_Audit_FSM_Routing_Key)
	end if
	
	if Glb_Audit_FSM_Hdl == 0
	then
		incr Local_Retry_times
		#retry 5 times
		if Local_Retry_times < 6
		then
			schedule(clock = clock() + 3, event = Get_FSM_Handle)
		end if
	end if
#	end call
end event Get_FSM_Handle

event Init_Server_Audit
	
	#init session audit
	set Do_Server_Audit.Audit_Tpye = AT_SESSION
	set Local_Next_Session_Audit_Timing = Glb_Server_Current_Clock + session_audit_interval
	schedule(event = Do_Server_Audit, clock = Local_Next_Session_Audit_Timing)

	#init order audit
	set Do_Server_Audit.Audit_Tpye = AT_ORDER
	set Local_Next_Order_Audit_Timing = Glb_Server_Current_Clock + order_audit_interval
	schedule(event = Do_Server_Audit, clock = Local_Next_Order_Audit_Timing)

	#init ticket audit, add tickets now
	set Do_Server_Audit.Audit_Tpye = AT_TICKET
	set Local_Ticketing_Audit_Total = table_length(Train_Info)
	set Local_Next_Ticketing_Audit_Day = date!present()
	set Local_Next_Ticketing_Audit_Timing = Glb_Server_Current_Clock + 1
	schedule(event = Do_Server_Audit, clock = Local_Next_Ticketing_Audit_Timing)
end event
event Do_Server_Audit
	test @.Audit_Tpye
	#init session audit
	case AT_SESSION
		reset Local_Session_Audit_Next
		#set Do_Server_Audit.Audit_Tpye = AT_SESSION
		set Local_Next_Session_Audit_Timing = Glb_Server_Current_Clock + session_audit_interval
		schedule(event = Do_Server_Audit, clock = Local_Next_Session_Audit_Timing)
		next event Do_Server_Session_Audit	
	#init order audit
	case AT_ORDER
		#set Do_Server_Audit.Audit_Tpye = AT_ORDER
		set Local_Next_Order_Audit_Timing = Glb_Server_Current_Clock + order_audit_interval
		schedule(event = Do_Server_Audit, clock = Local_Next_Order_Audit_Timing)
		next event Do_Server_Order_Audit
	#init ticket audit
	case AT_TICKET
		#set Do_Server_Audit.Audit_Tpye = AT_TICKET
		set Local_Next_Ticketing_Audit_Timing = Glb_Server_Current_Clock + tickets_audit_interval
		schedule(event = Do_Server_Audit, clock = Local_Next_Ticketing_Audit_Timing)
		next event Do_Server_Ticketing_Audit
	#error accured
	other
	end test
end event Do_Server_Audit

event Do_Server_Session_Audit
	Session_RTDB!get_next(instance = Glb_Session_RTDB, next_index = Local_Session_Audit_Next)
end event Do_Server_Session_Audit

event Audit_Check_Session
	if @.session_fields.Last_Active_TS +  session_expire_interval < Glb_Server_Current_Clock
	then
		set Audit_Delete_Session.session_id = @.session_fields.Session_ID
		next event Audit_Delete_Session
	else
		next event Do_Server_Session_Audit
	end if
end event Audit_Check_Session

event Audit_Delete_Session
	Session_RTDB!delete(instance = Glb_Session_RTDB, Session_ID = @.session_id)
end event Audit_Delete_Session

event Session_RTDB!delete_completed
	next event Do_Server_Session_Audit
end event Session_RTDB!delete_completed

event Session_RTDB!delete_failed
	send_om( msg_class = GSL_Assert_Message_Class, title = Glb_RTDB_Operation_Assert_Title,
		poa = GSL_Assert_Priority, message = "Session_RTDB delete failed" : string( @.failure_reason ))
	set Action_Result.result = FAIL
	set Action_Result.message = "session audit failed - system error"
	next event Action_Result	
end event Session_RTDB!delete_failed

event Session_RTDB!get_next_completed
	set Audit_Check_Session.session_fields = @.data
	set Local_Session_Audit_Next = @.next_index
	next event Audit_Check_Session
end event Session_RTDB!get_next_completed

event Session_RTDB!get_next_failed
	if @.failure_reason == e_entry_out_of_range
	then
		set Action_Result.result = SUCCESS
		set Action_Result.message = "session audit success"
		next event Action_Result
	else
		send_om( msg_class = GSL_Assert_Message_Class, title = Glb_RTDB_Operation_Assert_Title,
			poa = GSL_Assert_Priority, message = "Session_RTDB get_next failed" : string( @.failure_reason ))
		set Action_Result.result = FAIL
		set Action_Result.message = "session audit failed - system error"
		next event Action_Result
	end if
end event Session_RTDB!get_next_failed

event Do_Server_Order_Audit
	Order_RTDB!get_next(instance = Glb_Order_RTDB, next_index = Local_Order_Audit_Next)
end event Do_Server_Order_Audit

event Audit_Check_Order
	if @.order_fields.State != SUCCESS
		&& (@.order_fields.Creation_TS + order_expire_interval < Glb_Server_Current_Clock)
	then
		set Audit_Delete_Order.order_id = @.order_fields.Order_ID
		set Local_Order_Audit_Ticket_ID = @.order_fields.Ticket_ID
		next event Audit_Delete_Order
	else
		next event Do_Server_Order_Audit
	end if
end event Audit_Check_Order

event Audit_Delete_Order
	Order_RTDB!delete(instance = Glb_Order_RTDB, Order_ID = @.order_id)
end event Audit_Delete_Order

event Order_RTDB!delete_completed
	set Order_Audit_Read_Tickets.ticket_id = Local_Order_Audit_Ticket_ID
	next event Order_Audit_Read_Tickets
end event Order_RTDB!delete_completed

event Order_Audit_Read_Tickets
	Ticket_Info_RTDB!read(instance = Glb_Ticket_Info_RTDB, Ticket_Id = @.ticket_id)
end event Order_Audit_Read_Tickets

event Ticket_Info_RTDB!read_completed
	set Order_Audit_Update_Tickets.ticket_info = @.data
	next event Order_Audit_Update_Tickets
end event Ticket_Info_RTDB!read_completed

event Ticket_Info_RTDB!read_failed
	send_om( msg_class = GSL_Assert_Message_Class, title = Glb_RTDB_Operation_Assert_Title,
		poa = GSL_Assert_Priority, message = "Ticket_Info_RTDB read failed" : string( @.failure_reason ))
	set Action_Result.result = FAIL
	set Action_Result.message = "order audit failed - system error"
	#add a unfinished work
	set Order_Audit_Read_Tickets.ticket_id = Local_Order_Audit_Ticket_ID
	schedule(clock =  Glb_Server_Current_Clock + 3, event = Order_Audit_Read_Tickets)	
	next event Action_Result	
end event Ticket_Info_RTDB!read_failed

event Order_Audit_Update_Tickets
dynamic
	Local_Ticket_Info Ticket_Info_RTDB_fields
	Local_Ticket_present Ticket_Info_RTDB_present
end dynamic
	set Local_Ticket_Info = @.ticket_info
	incr Local_Ticket_Info.Available_Seats
	Ticket_Info_RTDB!update(instance = Glb_Ticket_Info_RTDB, data = Local_Ticket_Info, present = Local_Ticket_present)
end event Order_Audit_Update_Tickets

event Ticket_Info_RTDB!update_completed
	next event Do_Server_Order_Audit
end event Ticket_Info_RTDB!update_completed

event Ticket_Info_RTDB!update_failed
	send_om( msg_class = GSL_Assert_Message_Class, title = Glb_RTDB_Operation_Assert_Title,
		poa = GSL_Assert_Priority, message = "Ticket_Info_RTDB update failed" : string( @.failure_reason ))
	set Action_Result.result = FAIL
	set Action_Result.message = "order audit failed - system error"
	#add a unfinished work
	set Order_Audit_Read_Tickets.ticket_id = Local_Order_Audit_Ticket_ID
	schedule(clock =  Glb_Server_Current_Clock + 3, event = Order_Audit_Read_Tickets)	
	next event Action_Result	
end event Ticket_Info_RTDB!update_failed

event Order_RTDB!delete_failed
	send_om( msg_class = GSL_Assert_Message_Class, title = Glb_RTDB_Operation_Assert_Title,
		poa = GSL_Assert_Priority, message = "Order_RTDB delete failed" : string( @.failure_reason ))
	set Action_Result.result = FAIL
	set Action_Result.message = "order audit failed - system error"
	next event Action_Result	
end event Order_RTDB!delete_failed

event Order_RTDB!get_next_completed
	set Audit_Check_Order.order_fields = @.data
	set Local_Order_Audit_Next = @.next_index
	next event Audit_Check_Order
end event Order_RTDB!get_next_completed

event Order_RTDB!get_next_failed
	if @.failure_reason == e_entry_out_of_range
	then
		set Action_Result.result = SUCCESS
		set Action_Result.message = "order audit success"
		next event Action_Result
	else
		send_om( msg_class = GSL_Assert_Message_Class, title = Glb_RTDB_Operation_Assert_Title,
			poa = GSL_Assert_Priority, message = "Order_RTDB get_next failed" : string( @.failure_reason ))
		set Action_Result.result = FAIL
		set Action_Result.message = "order audit failed - system error"
		next event Action_Result
	end if
end event Order_RTDB!get_next_failed


event Do_Server_Ticketing_Audit

dynamic
	Ticket_Rec Ticket_Info_RTDB_fields
end dynamic
	if Local_Ticketing_Audit_Next > Local_Ticketing_Audit_Total
	then
		reset Local_Ticketing_Audit_Next
		set Action_Result.result = SUCCESS
		set Action_Result.message = "session audit success"
		incr Local_Next_Ticketing_Audit_Day
		if clock(Local_Next_Ticketing_Audit_Day)< clock(date!present()) + 24*3600
		then
			schedule(clock = Glb_Server_Current_Clock + 2, event = Do_Server_Ticketing_Audit)
		else
			next event Action_Result
		end if
		return
	end if

	if Local_Ticketing_Audit_Next == 0
	then
		set Local_Ticketing_Audit_Next = 1
	end if
	
	set Ticket_Rec.Ticket_Id = Train_Info.Train_Number : string(Local_Next_Ticketing_Audit_Day.year):string(Local_Next_Ticketing_Audit_Day.month):string(Local_Next_Ticketing_Audit_Day.day)
	set Ticket_Rec.Train_Id = Train_Info.Train_Number
	set Ticket_Rec.Start_Station = Train_Info.Start_Station
	set Ticket_Rec.End_Station = Train_Info.Destination
	set Ticket_Rec.Start_Time_ST = clock(Local_Next_Ticketing_Audit_Day, Train_Info.Departure_Time)
	set Ticket_Rec.End_Time_ST = clock(Local_Next_Ticketing_Audit_Day, Train_Info.Arrival_Time) 
	set Ticket_Rec.Price = Train_Info.Price
	set Ticket_Rec.Total_Seats = Train_Info.Total
	set Ticket_Rec.Available_Seats = Train_Info.Total

	Ticket_Info_RTDB!insert(instance = Glb_Ticket_Info_RTDB, data = Ticket_Rec)
	return
end event

event Ticket_Info_RTDB!insert_completed
	incr Local_Ticketing_Audit_Next
	next event Do_Server_Ticketing_Audit
	return
end event  Ticket_Info_RTDB!insert_completed

event Ticket_Info_RTDB!insert_failed
	if @.failure_reason != e_duplicate_key
	then 
		send_om( msg_class = GSL_Assert_Message_Class,
			title = Glb_RTDB_Operation_Assert_Title,
			poa = GSL_Assert_Priority,
			message = "Ticket_Info_RTDB operation error" : string( @.failure_reason ))
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing audit failed - system error"
		next event Action_Result
		return
	end if
	return
end event Ticket_Info_RTDB!insert_failed

event Action_Result
	next event End_Call
	return
end event Action_Result

event End_Call
	end_call
end event End_Call

end fsm


fsm Srv_Ticketing_FSM
type
	
end type
	
call_dynamic
	BCI_Reserve_Request	Reserve_Request
	Action_Result				def_event {
		result			Result_Code,
		message			string
	}
	End_Call				def_event {}
	Check_User_Info def_event {
	}
	Reserve_Ticket def_event {
		session_id		counter,
		user_id				string,
		ticket_id			string,
		ticket_num		counter,
	}
end call_dynamic

access
	Srv_Ticketing_FSM_Routing_Key		routing_string
end access

event Check_Ticket_Info
dynamic
	Local_Ret		flag
end dynamic
	if Glb_Ticket_Info_RTDB_Lock == false
	then
		set Glb_Ticket_Info_RTDB_Lock = true
		Ticket_Info_RTDB!read(instance = Glb_Ticket_Info_RTDB, Ticket_Id = BCI_Reserve_Request.ticket_id)
	else
		#add the task to the queue
		set BCI_Reserve_Request.fail_type = TST_TICKET_RTDB_FAIL
		if BCI_Reserve_Request.Trans_Type == TT_NONE
		then
			set BCI_Reserve_Request.Trans_Type = TT_CONTINUE
			set Local_Ret = Add_Continue_Transaction(BCI_Reserve_Request)
		else
			set BCI_Reserve_Request.Trans_Type = TT_ROLL_BACK
			set Local_Ret = Add_Rollback_Transaction(BCI_Reserve_Request)
		end if
		if  Local_Ret == true
		then
			set Action_Result.result = PENDING
			set Action_Result.message = "ticketing reserve is in progress"
			next event Action_Result
		else
			set Action_Result.result = FAIL
			set Action_Result.message = "ticketing reserve failed( Ticket_Info_RTDB!read locked): ":BCI_Reserve_Request.user_id:string(BCI_Reserve_Request.session_id)
					:BCI_Reserve_Request.ticket_id:string(BCI_Reserve_Request.ticket_num):string(BCI_Reserve_Request.order_id)
			set Reserve_Ticket_failed.fail_reason = RFC_SYSTEM_BUSY
			xp_send(to =xp_dest_query() , event =Reserve_Ticket_failed, ack = false )
			next event Action_Result
		end if
	end if
	return
end event

event Ticket_Info_RTDB!read_completed
dynamic
	Local_Ticket_Info	Ticket_Info_RTDB_fields
	Local_Ticket_present	Ticket_Info_RTDB_present
end dynamic
	set Local_Ticket_Info = @.data
	if Local_Ticket_Info.Available_Seats < BCI_Reserve_Request.ticket_num
	then
		set Glb_Ticket_Info_RTDB_Lock = false
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing reserve failed"
		set Reserve_Ticket_failed.fail_reason = RFC_UNPAIED_ORDER
		xp_send(to = BCI_Reserve_Request.call_id , event = Reserve_Ticket_failed, ack = false)
		next event Action_Result
		return
	end if
	#check train time
	if Local_Ticket_Info.Start_Time_ST < clock()
	then
		set Glb_Ticket_Info_RTDB_Lock = false
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing reserve failed"
		set Reserve_Ticket_failed.fail_reason = RFC_SESSION_TIME_OUT
		xp_send(to = BCI_Reserve_Request.call_id , event = Reserve_Ticket_failed, ack = false)
		next event Action_Result
		return
	end if
	set BCI_Reserve_Request.train_id = Local_Ticket_Info.Train_Id
	set BCI_Reserve_Request.train_date = clock!date(Local_Ticket_Info.Start_Time_ST)
	set Local_Ticket_Info.Available_Seats = Local_Ticket_Info.Available_Seats - BCI_Reserve_Request.ticket_num
	Ticket_Info_RTDB!update(instance = Glb_Ticket_Info_RTDB, data = Local_Ticket_Info, present = Local_Ticket_present)		

	return
end event
event  Ticket_Info_RTDB!read_failed
dynamic
	Local_Ret		flag
end dynamic
	set Glb_Ticket_Info_RTDB_Lock = false
	#add the task to the queue
	set BCI_Reserve_Request.fail_type = TST_TICKET_RTDB_FAIL
	if BCI_Reserve_Request.Trans_Type == TT_NONE
	then
		set BCI_Reserve_Request.Trans_Type = TT_CONTINUE
		set Local_Ret = Add_Continue_Transaction(BCI_Reserve_Request)
	else
		set BCI_Reserve_Request.Trans_Type = TT_ROLL_BACK
		set Local_Ret = Add_Rollback_Transaction(BCI_Reserve_Request)
	end if
	if Local_Ret == true
	then
		set Action_Result.result = PENDING
		set Action_Result.message = "ticketing reserve is in progress"
		next event Action_Result
	else
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing reserve failed(Ticket_Info_RTDB!read_failed): ":BCI_Reserve_Request.user_id:string(BCI_Reserve_Request.session_id)
				:BCI_Reserve_Request.ticket_id:string(BCI_Reserve_Request.ticket_num):string(BCI_Reserve_Request.order_id)
		set Reserve_Ticket_failed.fail_reason = RFC_SYSTEM_BUSY
		xp_send(to =xp_dest_query() , event =Reserve_Ticket_failed, ack = false )
		next event Action_Result
	end if
end event

event Ticket_Info_RTDB!update_completed
	#unlock the rtdb
	set Glb_Ticket_Info_RTDB_Lock = false
	next event Add_New_Order
	return
end event

event Ticket_Info_RTDB!update_failed
dynamic
	Local_Ret		flag
end dynamic
	set Glb_Ticket_Info_RTDB_Lock = false
	#add the task to the queue
	set BCI_Reserve_Request.fail_type = TST_TICKET_RTDB_FAIL
	set BCI_Reserve_Request.fail_type = TST_TICKET_RTDB_FAIL
	if BCI_Reserve_Request.Trans_Type == TT_NONE
	then
		set BCI_Reserve_Request.Trans_Type = TT_CONTINUE
		set Local_Ret = Add_Continue_Transaction(BCI_Reserve_Request)
	else
		set BCI_Reserve_Request.Trans_Type = TT_ROLL_BACK
		set Local_Ret = Add_Rollback_Transaction(BCI_Reserve_Request)
	end if
	if  Local_Ret == true
	then
		set Action_Result.result = PENDING
		set Action_Result.message = "ticketing reserve is in progress"
		next event Action_Result
	else
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing reserve failed( Ticket_Info_RTDB!update_failed): ":BCI_Reserve_Request.user_id:string(BCI_Reserve_Request.session_id)
				:BCI_Reserve_Request.ticket_id:string(BCI_Reserve_Request.ticket_num):string(BCI_Reserve_Request.order_id)
		set Reserve_Ticket_failed.fail_reason = RFC_SYSTEM_BUSY
		xp_send(to =xp_dest_query() , event =Reserve_Ticket_failed, ack = false )
		next event Action_Result
	end if
end event

event Add_New_Order
dynamic
	Local_Order		Order_RTDB_fields
end dynamic
	#add a order
	set Local_Order.Order_ID = Glb_Current_Order_Id
	set BCI_Reserve_Request.order_id = Glb_Current_Order_Id
	incr Glb_Current_Order_Id
	set Local_Order.Creation_TS = clock()
	set Local_Order.User_ID = BCI_Reserve_Request.user_id
	set Local_Order.Ticket_ID = BCI_Reserve_Request.ticket_id
	set Local_Order.Train_Number = substring((BCI_Reserve_Request.ticket_id), 1, length(BCI_Reserve_Request.ticket_id)-6) 
	set Local_Order.Train_Date = string(BCI_Reserve_Request.train_date)
	set Local_Order.State = OS_UNPAIED
	Order_RTDB!insert(instance = Glb_Order_RTDB, data = Local_Order)
end event Add_New_Order

event Order_RTDB!insert_completed

	next event Update_User_Info
end event

event Order_RTDB!insert_failed
dynamic
	Local_Ret		flag
end dynamic
	#add the task to the queue
	set BCI_Reserve_Request.fail_type = TST_ORDER_RTDB_FAIL
	set BCI_Reserve_Request.fail_type = TST_TICKET_RTDB_FAIL
	if BCI_Reserve_Request.Trans_Type == TT_NONE
	then
		set BCI_Reserve_Request.Trans_Type = TT_CONTINUE
		set Local_Ret = Add_Continue_Transaction(BCI_Reserve_Request)
	else
		set BCI_Reserve_Request.Trans_Type = TT_ROLL_BACK
		set Local_Ret = Add_Rollback_Transaction(BCI_Reserve_Request)
	end if
	if  Local_Ret == true
	then
		set Action_Result.result = PENDING
		set Action_Result.message = "ticketing reserve is in progress"
		next event Action_Result
	else
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing reserve failed( Order_RTDB!insert_failed): ":BCI_Reserve_Request.user_id:string(BCI_Reserve_Request.session_id)
				:BCI_Reserve_Request.ticket_id:string(BCI_Reserve_Request.ticket_num):string(BCI_Reserve_Request.order_id)
		set Reserve_Ticket_failed.fail_reason = RFC_SYSTEM_BUSY
		xp_send(to =xp_dest_query() , event =Reserve_Ticket_failed, ack = false )
		next event Action_Result
	end if
end event

event Update_User_Info
dynamic
	Local_Ret		flag
end dynamic
	if Try_Lock_User(BCI_Reserve_Request.user_id) == true
	then
		User_Account_RTDB!read(instance = Glb_User_Account_RTDB, User_ID = BCI_Reserve_Request.user_id)
	else
		#add the task to the queue
		set BCI_Reserve_Request.fail_type = TST_USER_RTDB_FAIL
		set BCI_Reserve_Request.fail_type = TST_TICKET_RTDB_FAIL
		if BCI_Reserve_Request.Trans_Type == TT_NONE
		then
			set BCI_Reserve_Request.Trans_Type = TT_CONTINUE
			set Local_Ret = Add_Continue_Transaction(BCI_Reserve_Request)
		else
			set BCI_Reserve_Request.Trans_Type = TT_ROLL_BACK
			set Local_Ret = Add_Rollback_Transaction(BCI_Reserve_Request)
		end if
		if  Local_Ret == true
		then
			set Action_Result.result = PENDING
			set Action_Result.message = "ticketing reserve is in progress"
			next event Action_Result
		else
			set Action_Result.result = FAIL
			set Action_Result.message = "ticketing reserve failed(User_Account_RTDB locked): ":BCI_Reserve_Request.user_id:string(BCI_Reserve_Request.session_id)
					:BCI_Reserve_Request.ticket_id:string(BCI_Reserve_Request.ticket_num):string(BCI_Reserve_Request.order_id)
			set Reserve_Ticket_failed.fail_reason = RFC_SYSTEM_BUSY
			xp_send(to =xp_dest_query() , event =Reserve_Ticket_failed, ack = false )
			next event Action_Result
		end if
	end if
end event

event User_Account_RTDB!read_completed
dynamic
	Local_User_Info	User_Account_RTDB_fields
	Local_User_present	User_Account_RTDB_present
end dynamic
	set Local_User_Info = @.data
	test Local_User_Info.Latest_Index
	case 0
		if Local_User_Info.Order_ID_0 == 0
		then
			set Local_User_Info.Order_ID_0 = BCI_Reserve_Request.order_id
		else
			set Local_User_Info.Latest_Index = 1
			set Local_User_Info.Order_ID_1 = BCI_Reserve_Request.order_id
		end if
	case 1
		set Local_User_Info.Latest_Index = 2
		set Local_User_Info.Order_ID_2 = BCI_Reserve_Request.order_id
	case 2
		set Local_User_Info.Latest_Index = 3
		set Local_User_Info.Order_ID_3 = BCI_Reserve_Request.order_id
	case 3
		set Local_User_Info.Latest_Index = 4
		set Local_User_Info.Order_ID_4 = BCI_Reserve_Request.order_id
	case 4
		set Local_User_Info.Latest_Index = 5
		set Local_User_Info.Order_ID_5 = BCI_Reserve_Request.order_id
	case 5
		set Local_User_Info.Latest_Index = 6
		set Local_User_Info.Order_ID_6 = BCI_Reserve_Request.order_id
	case 6
		set Local_User_Info.Latest_Index = 7
		set Local_User_Info.Order_ID_7 = BCI_Reserve_Request.order_id
	case 7
		set Local_User_Info.Latest_Index = 8
		set Local_User_Info.Order_ID_8 = BCI_Reserve_Request.order_id
	case 8
		set Local_User_Info.Latest_Index = 9
		set Local_User_Info.Order_ID_9 = BCI_Reserve_Request.order_id
	case 9
		set Local_User_Info.Latest_Index =0
		set Local_User_Info.Order_ID_0 = BCI_Reserve_Request.order_id
	other
	end test

	User_Account_RTDB!update(instance = Glb_User_Account_RTDB, data = Local_User_Info, present = Local_User_present)		
	return
end event

event User_Account_RTDB!read_failed
dynamic
	Local_Ret		flag
end dynamic
 	if UnLock_User(BCI_Reserve_Request.user_id)  == true
 	then
 	end if
	#add the task to the queue
	set BCI_Reserve_Request.fail_type = TST_USER_RTDB_FAIL
	set BCI_Reserve_Request.fail_type = TST_TICKET_RTDB_FAIL
	if BCI_Reserve_Request.Trans_Type == TT_NONE
	then
		set BCI_Reserve_Request.Trans_Type = TT_CONTINUE
		set Local_Ret = Add_Continue_Transaction(BCI_Reserve_Request)
	else
		set BCI_Reserve_Request.Trans_Type = TT_ROLL_BACK
		set Local_Ret = Add_Rollback_Transaction(BCI_Reserve_Request)
	end if
	if  Local_Ret == true
	then
		set Action_Result.result = PENDING
		set Action_Result.message = "ticketing reserve is in progress"
		next event Action_Result
	else
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing reserve failed(User_Account_RTDB!read_failed): ":BCI_Reserve_Request.user_id:string(BCI_Reserve_Request.session_id)
				:BCI_Reserve_Request.ticket_id:string(BCI_Reserve_Request.ticket_num):string(BCI_Reserve_Request.order_id)
		set Reserve_Ticket_failed.fail_reason = RFC_SYSTEM_BUSY
		xp_send(to =xp_dest_query() , event =Reserve_Ticket_failed, ack = false )
		next event Action_Result
	end if
end event

event User_Account_RTDB!update_completed
	set Action_Result.result = SUCCESS
	set Action_Result.message = "ticketing reserve success"
	set Reserve_Ticket_success.order_id = BCI_Reserve_Request.order_id
	xp_send(to = BCI_Reserve_Request.call_id , event = Reserve_Ticket_success, ack = false)
	next event Action_Result
end event

event User_Account_RTDB!update_failed
 dynamic
	Local_Ret		flag
end dynamic
	if UnLock_User(BCI_Reserve_Request.user_id)  == true
 	then
 	end if
	#add the task to the queue
	set BCI_Reserve_Request.fail_type = TST_USER_RTDB_FAIL
	set BCI_Reserve_Request.fail_type = TST_TICKET_RTDB_FAIL
	if BCI_Reserve_Request.Trans_Type == TT_NONE
	then
		set BCI_Reserve_Request.Trans_Type = TT_CONTINUE
		set Local_Ret = Add_Continue_Transaction(BCI_Reserve_Request)
	else
		set BCI_Reserve_Request.Trans_Type = TT_ROLL_BACK
		set Local_Ret = Add_Rollback_Transaction(BCI_Reserve_Request)
	end if
	if  Local_Ret == true
	then
		set Action_Result.result = PENDING
		set Action_Result.message = "ticketing reserve is in progress"
		next event Action_Result
	else
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing reserve failed(User_Account_RTDB!read_failed): ":BCI_Reserve_Request.user_id:string(BCI_Reserve_Request.session_id)
				:BCI_Reserve_Request.ticket_id:string(BCI_Reserve_Request.ticket_num):string(BCI_Reserve_Request.order_id)
		set Reserve_Ticket_failed.fail_reason = RFC_SYSTEM_BUSY
		xp_send(to =xp_dest_query() , event =Reserve_Ticket_failed, ack = false )
		next event Action_Result
	end if
end event

event Reserve_Ticket
	#check input parameters
	
	if @.session_id == 0 || @.ticket_num == 0 ||  @.user_id == "" || @.ticket_id == ""
	then
		set Action_Result.result = FAIL
		set Action_Result.message = "ticketing reserve failed"
		set Reserve_Ticket_failed.fail_reason = RFC_INVALIED_ACTION
		xp_send(to =xp_dest_query() , event =Reserve_Ticket_failed, ack = false )
		next event Action_Result
		return
	end if

	#set request info
	set BCI_Reserve_Request.session_id =  @.session_id
	set BCI_Reserve_Request.user_id =  @.user_id
	set BCI_Reserve_Request.ticket_id =  @.ticket_id
	set BCI_Reserve_Request.ticket_num =  @.ticket_num
	set BCI_Reserve_Request.call_id =  xp_dest_query()
	#check user info
	next event Check_Ticket_Info
	return
end event

event Reserve_Continue
	set BCI_Reserve_Request = @.request_info
	test BCI_Reserve_Request.fail_type
	case TST_TICKET_RTDB_FAIL
		next event Check_Ticket_Info
	case TST_ORDER_RTDB_FAIL
		next event Add_New_Order
	case TST_USER_RTDB_FAIL
		next event Update_User_Info
	other
	end test
	return
end event

event Action_Result
	next event End_Call
	return
end event Action_Result

event End_Call
	end_call
end event End_Call

end fsm

fsm Srv_Trans_Manage_FSM

type

end type

call_dynamic
	BCI_Current_Trans_Index		counter
	BCI_Current_ROLLBACK_Index		counter
	BCI_Remain_Transaction_Once		counter

end call_dynamic

event Transanction_Manage
	timer!start(duration = 3)
end event Transanction_Manage

event time_out
	set BCI_Remain_Transaction_Once = 20
	next event Deal_Next_Transaction
end event time_out

event Deal_Next_Transaction
	if table_length(Glb_Trans_Continue_tbl) <= 0
	then
		next event Deal_Next_Rollback
	end if
	if BCI_Remain_Transaction_Once >0 
	then
		decr BCI_Remain_Transaction_Once
		test Glb_Trans_Continue_tbl[0].fail_type
		case TST_TICKET_RTDB_FAIL
			send(to = parent_index(), event = Check_Ticket_Info, ack = true)
		case TST_ORDER_RTDB_FAIL
			send(to = parent_index(), event = Add_New_Order, ack = true)
		case TST_USER_RTDB_FAIL
			send(to = parent_index(), event = Update_User_Info, ack = true)
		other
		end test
	else
		next event Transanction_Manage
	end if
end event

event Reserve_Ticket_failed
	next event Deal_Next_Transaction
end event Reserve_Ticket_failed

event Reserve_Ticket_success 
	next event Deal_Next_Transaction
end event Reserve_Ticket_success 

event Deal_Next_Rollback
	if table_length(Glb_Trans_Rollback_tbl) <= 0 || BCI_Remain_Transaction_Once <= 0 
	then
		next event Transanction_Manage
	end if





end event




end fsm


fsm Srv_Routing_FSM


end fsm

end server

########################################################################
########		   Client Definition			########
########################################################################
client
type
	Dataview_Info_rec			record {
		name			string,
		instance		counter,
		is_attached		flag,
	}
	RTDB_Init def_event {
	}

end type

dynamic

	a_z					string(26)
	A_Z					string(26)
	
	MAX_Balance				counter

	Glb_SPA_NAME				string
	Glb_Client_ID				counter

	# send om parameters
	GSL_Assert_Message_Class		message_class
	GSL_Assert_Priority			priority_of_action

	Glb_RTDB_Data_Assert_Title		string
	Glb_EPAY_RC_Assert_Title		string
	Glb_Dynamic_Data_Assert_Title		string
	Glb_Overflow_Assert_Title		string
	Glb_Internal_Operation_Assert_Title	string
	Glb_RTDB_Operation_Assert_Title		string
	# end semd om parameters

	Glb_Register_Dataview_Info		Dataview_Info_rec
	Glb_Login_Dataview_Info			Dataview_Info_rec
	Glb_Return_Val				reason_enum

	Glb_User_Account_RTDB			counter
	Glb_Session_RTDB			counter

	Dataview_Init_All			def_event {}

end dynamic

def_function Parse (
	Delimiter				string,
	Input					string
)	Parse_Result_rec
dynamic
	Result					Parse_Result_rec
	Pos					counter
end dynamic
    set Pos = find(Delimiter, Input)
    if (Pos == 0)
    then # No Delimiter found in Input String
        set Result.head = Input
        reset Result.tail
    else
        set Result.head = substring(Input, 1, (Pos - 1))
        set Result.tail = substring(Input, (Pos + length(Delimiter)), (length(Input)))
    end if

    return (Result)
end def_function Parse

def_function Encrypt (
	Input					string
)	string

    return (Input)
end def_function Encrypt

def_function Gen_Session_ID (
	Input					string
)	string

    return (Input)
end def_function Gen_Session_ID

initialize
	set a_z = "abcdefghijklmnopqrstuvwxyz"
	set A_Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

	set Glb_SPA_NAME = "TICKET"
        set Glb_RTDB_Data_Assert_Title =
                        "REPT MANUAL ASSERT=103, SPA=" : Glb_SPA_NAME
    set Glb_EPAY_RC_Assert_Title =
                        "REPT MANUAL ASSERT=104, SPA=" : Glb_SPA_NAME

        set Glb_Dynamic_Data_Assert_Title =
                        "REPT INTERNAL ASSERT=302, SPA=" : Glb_SPA_NAME
        set Glb_Overflow_Assert_Title =
                        "REPT INTERNAL ASSERT=303, SPA=" : Glb_SPA_NAME
        set Glb_Internal_Operation_Assert_Title =
                        "REPT INTERNAL ASSERT=304, SPA=" : Glb_SPA_NAME
        set Glb_RTDB_Operation_Assert_Title =
                        "REPT INTERNAL ASSERT=305, SPA=" : Glb_SPA_NAME
end initialize

###########################################################################
# FSM REGISTER
###########################################################################
fsm REGISTER
access
	Register_Dataview			routing_string
end access

call_dynamic
	BCI_instance				counter
	BCI_request_id				counter
end call_dynamic

dynamic
	#--------------------------------------------------------------------------
	# FSM REGISTER Event Definitions
	#--------------------------------------------------------------------------
	Command_Parsing				def_event {
		text			string,
	}

	Register				def_event {
		phone			string,
		name			string,
		passwd			string,
	}

	Register_Result				def_event {
		result			Result_Code,
		message			string
	}

	End_Call				def_event {}

end dynamic

initialize
	if Register_Dataview != ""
	then
		set Glb_Register_Dataview_Info.name = Register_Dataview
		set Glb_Return_Val = register!attach_owner( Register_Dataview )

		if Glb_Return_Val == e_a_okay
		then
			set Glb_Register_Dataview_Info.instance =
				register!get_instance ( Register_Dataview )
		else	# attach_owner failed
			set Glb_Register_Dataview_Info.instance = 0
		end if

		if Glb_Return_Val == 0
		then
			print(Register_Dataview : ": dataview attach failed!\n")
		end if
	end if
end initialize

#-------------------------------------------------------------------------------
# Dataview Request Handlers
#
# Description	: Dataview handler that accepts Input Messages (IM's), handles
#		  the request, and reports status with a corresponding Output
#		  Message (OM).
#-------------------------------------------------------------------------------
event register!read_received
	if Glb_Register_Dataview_Info.instance == 0
	then
		print(Register_Dataview : ": dataview not running!\n")
		set Glb_Return_Val = register!send_read_failed(
			@.instance, @.request_id, e_application_error)
		next event End_Call
		return
	end if

	set BCI_instance = @.instance
	set BCI_request_id = @.request_id

	set Command_Parsing.text = @.text
	next event Command_Parsing
	return
end event register!read_received

event Command_Parsing
dynamic
	Parse_Result				Parse_Result_rec
	Head					string
	Remainder				string
	Option					string
	Value					string
end dynamic
	set Remainder = map( @.text, a_z:" ", A_Z )
	set Parse_Result = Parse( ":", @.text)
	set Head = Parse_Result.head
	set Remainder = Parse_Result.tail
	test Head
	case "RCHG"
		# Get Options
		while Remainder != ""
		do
			set Parse_Result = Parse( ",", Remainder )
			set Head = Parse_Result.head
			set Remainder = Parse_Result.tail
			set Parse_Result = Parse( "=", Head )
			set Option = Parse_Result.head
			set Value = Parse_Result.tail
			test Option
			case "PHONE"
				set Register.phone = Value
			case "NAME"
				set Register.name = Value
			case "PASSWD"
				set Register.passwd = Value
			other	# Option not recognized
				set Register_Result.result = FAIL
				set Register_Result.message = Option :
					": option not recognized"
				next event Register_Result
				return
			end test
		end while
		next event Register
		return
	other
		set Register_Result.result = FAIL
		set Register_Result.message = Head : ": command not recognized"
		next event Register_Result
		return
	end test
			
end event Command_Parsing

event Register
dynamic
	Account					User_Account_RTDB_fields
end dynamic

	if length(@.phone) != 13 || map(@.phone, "0123456789", "") == ""
	then
		set Register_Result.result = FAIL
		set Register_Result.message = "phone number format error"
		next event Register_Result
		return
	end if

	set Account.User_ID = @.phone
	set Account.Passwd = Encrypt( @.passwd )
	set Account.Name = @.name
	set Account.Phone = @.phone
	set Account.Registration_TS = clock()

	User_Account_RTDB!insert( instance = Glb_User_Account_RTDB,
		data = Account)
	
end event Register

event User_Account_RTDB!insert_completed
	set Register_Result.result = SUCCESS
	set Register_Result.message = "register successful"
	next event Register_Result
	return
end event User_Account_RTDB!insert_completed

event User_Account_RTDB!insert_failed
	set Register_Result.result = FAIL
	set Register_Result.message = string( @.failure_reason )
	next event Register_Result
	return
end event User_Account_RTDB!insert_failed

event Register_Result
dynamic
	Register_Dataview_Rec			register_fields
	Register_Dataview_Present		register_present
end dynamic
	set Register_Dataview_Rec.result_code = @.result
	set Register_Dataview_Rec.message = @.message
	set Register_Dataview_Present.result_code
	set Register_Dataview_Present.message
	set Glb_Return_Val = register!send_read_completed (
		BCI_instance, BCI_request_id,
		Register_Dataview_Rec, Register_Dataview_Present)

	next event End_Call
	return
end event Register_Result

event End_Call
	end_call
end event End_Call

end fsm REGISTER

###########################################################################
# FSM LOGIN
###########################################################################
fsm LOGIN
access
	Login_Dataview			routing_string
end access

call_dynamic
	BCI_instance				counter
	BCI_request_id				counter
	BCI_phone				string
	BCI_passwd				string
	BCI_Timestamp				counter
end call_dynamic

dynamic
	#--------------------------------------------------------------------------
	# FSM REGISTER Event Definitions
	#--------------------------------------------------------------------------
	Command_Parsing				def_event {
		text			string,
	}

	Account_Retrive					def_event {
		phone			string,
	}

	Account_Verification					def_event {
		passwd			string,
	}

	Update_Session						def_event {
	}

	Login_Result				def_event {
		result			Result_Code,
		message			string
	}

	End_Call				def_event {}

end dynamic

initialize
	if Login_Dataview != ""
	then
		set Glb_Login_Dataview_Info.name = Login_Dataview
		set Glb_Return_Val = register!attach_owner( Login_Dataview )

		if Glb_Return_Val == e_a_okay
		then
			set Glb_Login_Dataview_Info.instance =
				register!get_instance ( Login_Dataview )
		else	# attach_owner failed
			set Glb_Login_Dataview_Info.instance = 0
		end if

		if Glb_Return_Val == 0
		then
			print(Login_Dataview : ": dataview attach failed!\n")
		end if
	end if
end initialize

#-------------------------------------------------------------------------------
# Dataview Request Handlers
#
# Description	: Dataview handler that accepts Input Messages (IM's), handles
#		  the request, and reports status with a corresponding Output
#		  Message (OM).
#-------------------------------------------------------------------------------
event login!read_received
	if Glb_Login_Dataview_Info.instance == 0
	then
		print(Login_Dataview : ": dataview not running!\n")
		set Glb_Return_Val = login!send_read_failed(
			@.instance, @.request_id, e_application_error)
		next event End_Call
		return
	end if

	set BCI_instance = @.instance
	set BCI_request_id = @.request_id

	set Command_Parsing.text = @.text
	next event Command_Parsing
	return
end event login!read_received

event Command_Parsing
dynamic
	Parse_Result				Parse_Result_rec
	Head					string
	Remainder				string
	Option					string
	Value					string
end dynamic
	set Remainder = map( @.text, a_z:" ", A_Z )
	set Parse_Result = Parse( ":", @.text)
	set Head = Parse_Result.head
	set Remainder = Parse_Result.tail
	test Head
	case "LOGIN"
		# Get Options
		while Remainder != ""
		do
			set Parse_Result = Parse( ",", Remainder )
			set Head = Parse_Result.head
			set Remainder = Parse_Result.tail
			set Parse_Result = Parse( "=", Head )
			set Option = Parse_Result.head
			set Value = Parse_Result.tail
			test Option
			case "PHONE"
				set Account_Retrive.phone = Value
				set BCI_phone = Value
			case "PASSWD"
				set BCI_passwd = Encrypt( Value )
			other	# Option not recognized
				set Login_Result.result = FAIL
				set Login_Result.message = Option :
					": option not recognized"
				next event Login_Result
				return
			end test
		end while
		next event Account_Retrive
		return
	other
		set Login_Result.result = FAIL
		set Login_Result.message = Head : ": command not recognized"
		next event Login_Result
		return
	end test
			
end event Command_Parsing

event Account_Retrive

	if length(@.phone) != 13 || map(@.phone, "0123456789", "") == ""
	then
		set Login_Result.result = FAIL
		set Login_Result.message = "phone number format error"
		next event Login_Result
		return
	end if

	User_Account_RTDB!read( instance = Glb_User_Account_RTDB,
		User_ID = @.phone)
	
end event Account_Retrive

event Account_Verification
dynamic
	Session_Rec			Session_RTDB_fields
end dynamic
	if BCI_passwd != @.passwd
	then
		set Login_Result.result = FAIL
		set Login_Result.message = "login failed - wrong password"
		next event Login_Result
		return
	end if

	set BCI_Timestamp = clock()

	# Create Session
	set Session_Rec.Session_ID = Gen_Session_ID( BCI_phone )
	set Session_Rec.User_ID = BCI_phone
	set Session_Rec.Client_ID = Glb_Client_ID
	set Session_Rec.Start_TS = BCI_Timestamp
	set Session_Rec.Last_Active_TS = BCI_Timestamp

	Session_RTDB!insert( instance = Glb_Session_RTDB,
		data = Session_Rec )

end event Account_Verification

event User_Account_RTDB!read_completed
	set Account_Verification.passwd = @.data.Passwd
	next event Account_Verification
	return
end event User_Account_RTDB!read_completed

event User_Account_RTDB!read_failed
	if @.failure_reason != e_tuple_not_found
	then 
		send_om( msg_class = GSL_Assert_Message_Class,
			title = Glb_RTDB_Operation_Assert_Title,
			poa = GSL_Assert_Priority,
			message = "User_Account_RTDB operation error"
				: string( @.failure_reason ))
		set Login_Result.result = FAIL
		set Login_Result.message = "login failed - system error"
		next event Login_Result
		return
	end if

	# user_id not found
	set Login_Result.result = FAIL
	set Login_Result.message = "login failed - invalid account"
	next event Login_Result
	return
end event User_Account_RTDB!read_failed

event Session_RTDB!insert_completed
	set Login_Result.result = SUCCESS
	set Login_Result.message = "login successful"
	next event Login_Result
	return
end event Session_RTDB!insert_completed

event Session_RTDB!insert_failed
	if @.failure_reason != e_duplicate_key
	then 
		send_om( msg_class = GSL_Assert_Message_Class,
			title = Glb_RTDB_Operation_Assert_Title,
			poa = GSL_Assert_Priority,
			message = "Session_RTDB operation error"
				: string( @.failure_reason ))
		set Login_Result.result = FAIL
		set Login_Result.message = "login failed - system error"
		next event Login_Result
		return
	end if

	# duplicate session_id
	next event Update_Session
	return
end event Session_RTDB!insert_failed

event Update_Session
dynamic
	Session_Rec				Session_RTDB_fields
	Session_Rec_Present			Session_RTDB_present
end dynamic
	set Session_Rec.Session_ID = BCI_phone
	set Session_Rec.Client_ID = Glb_Client_ID
	set Session_Rec.Start_TS = BCI_Timestamp
	set Session_Rec.Last_Active_TS = BCI_Timestamp
	set Session_Rec_Present.Session_ID
	set Session_Rec_Present.Client_ID
	set Session_Rec_Present.Start_TS
	set Session_Rec_Present.Last_Active_TS

	Session_RTDB!update( instance = Glb_Session_RTDB,
		data = Session_Rec, present = Session_Rec_Present )

end event Update_Session

event Session_RTDB!update_completed
	set Login_Result.result = SUCCESS
	set Login_Result.message = "login successful"
	next event Login_Result
	return
end event Session_RTDB!update_completed

event Session_RTDB!update_failed
	send_om( msg_class = GSL_Assert_Message_Class,
		title = Glb_RTDB_Operation_Assert_Title,
		poa = GSL_Assert_Priority,
		message = "Session_RTDB operation error"
			: string( @.failure_reason ))
	set Login_Result.result = FAIL
	set Login_Result.message = "login failed - system error"
	next event Login_Result
	return
end event Session_RTDB!update_failed

event Login_Result
dynamic
	Login_Dataview_Rec			login_fields
	Login_Dataview_Present			login_present
end dynamic
	set Login_Dataview_Rec.result_code = @.result
	set Login_Dataview_Rec.message = @.message
	set Login_Dataview_Present.result_code
	set Login_Dataview_Present.message
	set Glb_Return_Val = login!send_read_completed(
		BCI_instance, BCI_request_id,
		Login_Dataview_Rec, Login_Dataview_Present )

	next event End_Call
	return
end event Login_Result

event End_Call
	end_call
end event End_Call

end fsm LOGIN


###########################################################################
# FSM RECHARGE
###########################################################################
fsm RECHARGE
access
	RECHARGE_Access_Key			routing_string
end access

dynamic
	#--------------------------------------------------------------------------
	# FSM RECHARGE Event Definitions
	#--------------------------------------------------------------------------
	Command_Parsing				def_event {
		text			string,
	}

	Account_Retrive					def_event {
		phone			string,
	}

	Account_Verification					def_event {
		passwd			string,
	}

	Recharge					def_event {}

	Recharge_Result				def_event {
		result			Result_Code,
		message			string
	}

	End_Call				def_event {}
end dynamic

call_dynamic
	BCI_usli_dn				counter
	BCI_phone				string
	BCI_passwd				string
	BCI_balance				string
	BCI_recharge_amount			string
	BCI_Timestamp				counter
	BCI_Amount					counter
end call_dynamic

#-------------------------------------------------------------------------------
# Event		: usli_request
#
# Description	: USLI handler that accepts Input Messages (IM's), handles
#		  the request, and reports status with a corresponding Output
#		  Message (OM).
#-------------------------------------------------------------------------------
event usli_request

	set Command_Parsing.text = @.text
	next evnet Command_Parsing
	return

end event usli_request

event Command_Parsing
dynamic
	Parse_Result				Parse_Result_rec
	Head					string
	Remainder				string
	Option					string
	Value					string
end dynamic
	set Remainder = map( @.text, a_z:" ", A_Z )
	set Parse_Result = Parse( ":", @.text)
	set Head = Parse_Result.head
	set Remainder = Parse_Result.tail
	test Head
	case "RCHG"
		# Get Options
		while Remainder != ""
		do
			set Parse_Result = Parse( ",", Remainder )
			set Head = Parse_Result.head
			set Remainder = Parse_Result.tail
			set Parse_Result = Parse( "=", Head )
			set Option = Parse_Result.head
			set Value = Parse_Result.tail
			test Option
			case "PHONE"
				set Account_Retrive.phone = Value
				set BCI_phone = Value
			case "PASSWD"
				set BCI_passwd = Encrypt( Value )
			case "AMMOUNT"
				set BCI_recharge_amount = Value
			other	# Option not recognized
				set Recharge_Result.result = FAIL
				set Recharge_Result.message = Option :
					": option not recognized"
				next event Recharge_Result
				return
			end test
		end while
		next event Account_Retrive
		return
	other
		set Recharge_Result.result = FAIL
		set Recharge_Result.message = Head : ": command not recognized"
		next event Recharge_Result
		return
	end test
			
end event Command_Parsing

event Account_Retrive

	if length(@.phone) != 13 || map(@.phone, "0123456789", "") == ""
	then
		set Recharge_Result.result = FAIL
		set Recharge_Result.message = "phone number format error"
		next event Recharge_Result
		return
	end if

	User_Account_RTDB!read( instance = Glb_User_Account_RTDB,
		User_ID = @.phone)
	
end event Account_Retrive

event Account_Verification
	if BCI_passwd != @.passwd
	then
		set Recharge_Result.result = FAIL
		set Recharge_Result.message = "recharge failed - wrong password"
		next event Recharge_Result
		return
	end if

	next event Recharge

end event Account_Verification

event Recharge
dynamic
	Account_Rec				User_Account_RTDB_fields
	Account_Rec_Present			User_Account_RTDB_present
	New_Balance			counter
end dynamic
	set New_Balance = BCI_balance + BCI_Amount
	if New_Balance > MAX_Balance
	then
		set Recharge_Result.result = FAIL
		set Recharge_Result.message = "recharge failed - max balance exceeded"
		next event Recharge_Result
		return
	end if

	set Account_Rec.Balance = New_Balance
	#set Account_Rec.Balance
	#set Account_Rec.Last_Active_TS = BCI_Timestamp
	#set Account_Rec.Last_Active_TS
	User_Account_RTDB!update( instance = Glb_User_Account_RTDB,
		data = Account_Rec, present = Account_Rec_Present )

end event Recharge

event User_Account_RTDB!read_completed
	set BCI_balance = @.data.Balance
	set Account_Verification.passwd = @.data.Passwd
	next event Account_Verification
	return
end event User_Account_RTDB!read_completed

event User_Account_RTDB!read_failed
	if @.failure_reason != e_tuple_not_found
	then 
		send_om( msg_class = GSL_Assert_Message_Class,
			title = Glb_RTDB_Operation_Assert_Title,
			poa = GSL_Assert_Priority,
			message = "User_Account_RTDB operation error"
				: string( @.failure_reason ))
		set Recharge_Result.result = FAIL
		set Recharge_Result.message = "recharge failed - system error"
		next event Recharge_Result
		return
	end if

	# user_id not found
	set Recharge_Result.result = FAIL
	set Recharge_Result.message = "recharge failed - invalid account"
	next event Recharge_Result
	return
end event User_Account_RTDB!read_failed

event User_Account_RTDB!update_completed
	set Recharge_Result.result = SUCCESS
	set Recharge_Result.message = "recharge succeeded"
	next event Recharge_Result
	return
end event User_Account_RTDB!update_completed

event User_Account_RTDB!update_failed
	send_om( msg_class = GSL_Assert_Message_Class,
		title = Glb_RTDB_Operation_Assert_Title,
		poa = GSL_Assert_Priority,
		message = "User_Account_RTDB operation error"
			: string( @.failure_reason ))
	set Rechare_Result.result = FAIL
	set Rechare_Result.message = "recharge failed - system error"
	next event Rechare_Result
	return
end event User_Account_RTDB!update_failed

# send usli_response success event
event usli_response_succeeded
	print ("\n usli_request success: ", @)
	next event End_Call
	return
end event usli_response_succeeded

# send usli_response fail
event usli_response_failed
	print ("\n usli_request failed: ", @)
	next event End_Call
	return
end event usli_response_failed

event End_Call
	end_call
end event

end fsm RECHARGE

###########################################################################
# FSM SERVICE
###########################################################################
fsm SERVICE
access
	SERVICE_Access_Key			routing_string
end access

dynamic

	Request_Handler				def_event {
	}

	End_Call				def_event {}
end dynamic

initialize
	#set Glb_Client_ID = CC_Enum_To_Client_Host( which_client_cc_am_i() )
	#schedule(event = RTDB_Init, clock = clock() + 3)
end initialize

event RTDB_Init
	set Glb_Return_Val = User_Account_RTDB!attach ( "User_Account_RTDB" )
	if Glb_Return_Val == e_out_of_memory
	then
		set Glb_Return_Val = User_Account_RTDB!attach_no_cache("User_Account_RTDB" )
		if Glb_Return_Val != e_a_okay
		then
			#handle attach_no_cache error and
			print ("User_Account_RTDB attach_no_cache failure")
		end if
	elif Glb_Return_Val != e_a_okay
	then
		#handle non memory error and
		print ("User_Account_RTDB attach non memory error")
	end if
	set Glb_User_Account_RTDB = User_Account_RTDB!get_instance( "User_Account_RTDB" )

	set Glb_Return_Val = Session_RTDB!attach ( "Session_RTDB" )
	if Glb_Return_Val == e_out_of_memory
	then
		set Glb_Return_Val = Session_RTDB!attach_no_cache("Session_RTDB" )
		if Glb_Return_Val != e_a_okay
		then
			#handle attach_no_cache error and
			print ("Session_RTDB attach_no_cache failure")
		end if
	elif Glb_Return_Val != e_a_okay
	then
		#handle non memory error and
		print ("Session_RTDB attach non memory error")
	end if
	set Glb_Session_RTDB = Session_RTDB!get_instance( "Session_RTDB" )

	next event End_Call
end event RTDB_Init
	
event Request_Handler
end event Request_Handler

event End_Call
	end_call
end event End_Call

end fsm SERVICE

end client
